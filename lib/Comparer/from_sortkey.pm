package Comparer::from_sortkey;

use 5.010001;
use strict 'subs', 'vars';
use warnings;

# AUTHORITY
# DATE
# DIST
# VERSION

sub meta {
    return +{
        v => 1,
        args => {
            sortkey => {schema=>'perl::sortkey::modname_with_optional_args*', req=>1},
            reverse => {schema => 'bool*'},
            ci => {schema => 'bool*'},
        },
    };
}

sub gen_comparer {
    my %args = @_;

    my $sortkey = $args{sortkey} or die "Please specify sortkey";
    my $reverse = $args{reverse};
    my $ci = $args{ci};

    require Module::Load::Util;

    my ($mod, $args) = Module::Load::Util::_normalize_module_with_optional_args($sortkey);
    $mod = Module::Load::Util::_load_module({ns_prefix=>"SortKey"}, $mod);
    my $is_num = $mod =~ /\ASortKey::Num::/ ? 1:0;
    my $keygen = &{"$mod\::gen_keygen"}(@$args);

    sub {
        (
            $is_num ? ($keygen->($_[0]) <=> $keygen->($_[1])) :
            $args{ci} ? (lc($keygen->($_[0])) cmp lc($keygen->($_[1]))) : ($keygen->($_[0]) cmp $keygen->($_[1]))
        ) * ($args{reverse} ? -1 : 1)
    };
}

1;
# ABSTRACT: Compare keys generated by a SortKey:: module

=for Pod::Coverage ^(meta|gen_comparer)$

=head1 SYNOPSIS

 use Comparer::from_sortkey;

 my $cmp = Comparer::from_sortkey::gen_comparer(sortkey => "Num::similarity,string,foo");
 my @sorted = sort { $cmp->($a,$b) } "food", "foolish", "foo", "bar";
 # => ("foo","food","bar","foolish")


=head1 DESCRIPTION

=cut
